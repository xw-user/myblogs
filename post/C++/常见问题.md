# C++基础问题

## new、delete、malloc、free关系

```c
int* p = (int *) malloc (sizeof(int));
free(p);
p = NULL;
```

- 是否调用构造函数和析构函数

  new和delete是C++的运算符，在申请和释放空间的时候会调用对象的构造和析构函数，malloc和free是c的库函数，只是申请空间。

- 返回值

  new分配成功，返回对象类型的指针，不需要进行类型转换，符合类型安全；new内存分配失败，抛出bac_alloc异常，不会返回NULL，不需要额外判断返回值。

  malloc分配成功返回void*，需要进行强制类型转换。malloc失败返回NULL，需要额外判断。

- 是否可以重载

  new、delete可以重载，malloc和free不可以。

- 对数组的处理

  C++提供new[]与delete[]来专门处理数组类型，他会分别调用构造函数初始化数组中每个元素，释放时为每个对象调用析构函数。

- 重新分配内存

  malloc分配的空间不够，可以使用realloc对内存重新分配实现内存的扩充。

  new没有这样的操作。



## C和C++的区别

C是面向过程，C++是面向对象。

面向过程跟人的思考过程类似，将问题分成多个步骤，每个步骤封装一个函数，然后按照顺序执行。

面向对象比较抽象，将问题分成多个对象，每个对象描述具体的行为。

例如一个五子棋系统，如果是面向过程编写，就是分成开始游戏、黑棋走、绘制图像、判断输赢、白棋走、绘制图像、判断输赢。如果是面向对象的话，首先分成黑白双方(行为一致)、绘画系统、检测系统、输出系统。

面向过程语言的性能高于面向对象，因为不涉及到类的继承、实例，开销小执行效率高。

面向对象的优点是：易维护、易复用，封装继承多态，可以设计出低耦合的系统。



函数重载：C语言是严格按照函数名，C++是函数名、参数列表、个数等判断。

inline函数，C的宏函数是在预编译阶段处理，C++的inline是在编译阶段处理，可以进行类型检查更加安全。

const：C的const被修饰后不能作为左值，可以不初始化，之后不能再初始化；C++必须初始化



## struct和class的区别

struct的默认访问权限和继承是public，class默认为private。

在C语言中，struct内部是不能定义函数的，因为C语言认为数据和操作是分开的，所以struct可以直接使用大括号进行初始化。

在C++中，对struct功能的扩展，struct内部可以定义函数、继承、多态。

如果struct和class定义了构造函数则不能使用大括号进行初始化，另外如果成员是private也不能直接初始化。





## C++的面向对象的三大特征

- 封装

  封装就是将一些属性隐藏起来，外界无法直接访问，增强安全性和简化编程，使用者不用了解实现细节，通过接口以及特定的权限来使用类成员。

- 继承

  继承指一个对象可以直接使用另一个对象的属性和方法。

  子类拥有父类所有的成员变量和成员方法，子类可以拥有父类没有的属性和方法

  private在子类中存在，但是无法访问。


- 多态

  多态可以以相同的方式处理不同类型的对象，允许子类指针赋值给父类指针。

  多态表现在两个方面：编译和运行

  编译的多态体现在函数和运算符的重载。

  运行时的多态体现在继承和虚函数。

## 虚函数、虚函数表

虚函数是用virtual关键字修饰的成员函数，允许子类重写。纯虚函数是在父类为子类保留一个函数名，在子类中重新定义，拥有纯虚函数的类是抽象类，不能创建实例。

虚函数表是一个函数指针表，虚函数表只包含函数指针，没有函数体。虚函数表有继承性、多态性。每个派生类的虚函数表继承基类的虚函数表，如果子类重写虚函数，将更新对应的虚函数指针。

每个类只有一个唯一的虚函数表，对象增加一个指针指向类的虚函数表，

Base->show()，首先判断show()是否为虚函数，如果是虚函数，找到Base指向的对象，通过对象的虚函数指针在对应虚函数表中找到对应的函数。

- 为什么把析构函数定义为虚函数？

  通过父类调用析构的时候，只会析构父类的内存，从而造成内存泄露，如果析构函数定义为虚函数，子类有一块基类的虚函数表的拷贝，在析构子类对象的时候删除虚函数表，然后调用父类的析构函数。

- 为什么构造函数不能是虚函数？

  虚函数都对应一个虚函数表，通过对象的虚函数指针找虚函数表，虚函数指针存储在内存空间中，如果构造函数时虚函数，对象还没有分配内存空间，不存在虚函数指针。

- 虚函数可以内联吗？

  虚函数可以内联，但是虚函数表现多态性质的时候不能内联。内联是建议编译器内联，虚函数的多态性在运行期。



通过对象找到对应的虚函数表。

```c
#include <bits/stdc++.h>
using namespace std;

class A{
private:
    int a;
public:
    virtual void show() { cout << "show" << endl; }
    virtual void display() { cout << "display" << endl; }
};

int main() {

    typedef void (*Func)(void);
    A a;

    // 虚函数表的地址
    cout << (int*)*(int*)(&a) << endl;

    Func f1 = (Func) *((int*)*(int*)(&a) + 0);
    Func f2 = (Func) *((int*)*(int*)(&a) + 1);
    f1();
    f2();

    return 0;
}
```



## 堆栈的区别

- 内存分配

  堆由程序员通过new，malloc申请释放

  栈由编译器自动分配释放，保存函数参数值和局部变量等。

- 系统响应

  堆是由操作系统通过链表记录内存空闲地址，当系统收到程序申请时，遍历链表，找到满足要求的内存空间进行分配。通过new分配的内存速度较慢，容易产生内存碎片，用起来方便灵活。

  栈，只要栈的剩余空间大于申请的空间，系统会为程序提供内存，否则栈溢出。编译器自动分配，速度块，程序员无法控制。

  

## 内存四区

- 代码区

  存放可执行文件的操作指令，只读防止运行时被修改。

- 静态区

  全局变量、静态变量、常量。

- 堆区

  存放程序动态分配的内存，大小不固定。

- 栈区

  存放程序临时创建的变量，后进先出的特点，方便保存恢复调用现场。

## 智能指针

为了安全的使用指针，引入智能指针的概念。智能指针类似常规指针，他负责自动释放指向的对象。

shared_ptr允许多个指针指向同一个对象，unique_ptr独占指向的对象，weak_ptr是弱引用，执行shared_ptr管理的对象可能存在循环引用。

## RAII机制

资源获取就是初始化，对象在构造函数中获取资源，在析构函数中释放构造函数获取的资源。



## 内存泄露

1、浅拷贝

2、构造函数和析构函数中没有匹配的调用new和delete函数

3、没有正确地清除嵌套的对象指针

4、在释放对象数组时在delete中没有使用方括号

5、指向对象的指针数组不等同于对象数组

6、没有将基类的析构函数定义为虚函数

7、野指针，没有初始化、free没有置空



## 基本数据类型

char ：1个字节

char*（即指针变量）: 4个字节，8个字节

short int : 2个字节

int： 4个字节

unsigned int : 4个字节

float: 4个字节

double:  8个字节

long:  4个字节，8个字节

long long: 8个字节

unsigned long: 4个字节，8个字节

## 什么是引用

引用是变量的别名，引用必须初始化，类中引用属性在类的初始化列表中完成。

引用作为函数的参数，不拷贝副本，直接对实参进行操作。

使用指针也可以有相同的效果，使用麻烦，需要为指针变量开辟空间。

## 引用和指针

引用需要初始化，指针不需要初始化

不存在指向空值的引用，存在指向空值的指针。

## 指针常量和常量指针

指针常量：指针本身是常量，不能修改指针的指向，可以修改指向的值。

常量指针：指向常量的指针，可以修改指针的指向，不可以修改指针指向的值。

## 结构体和联合

结构体和联合都可以由多个不同的数据类型组成，但是联合的所有成员公用地址空间，对联合中的成员赋值，会对其他成员重写。

## const和#define对比

const定义常量，修饰函数参数、返回值。被const修饰的东西受到强制保护，防止被修改。

const常量有数据类型，可以进行安全检查；宏常量没有数据类型，只是字符替换。



## volatile

使用 volatile 声明的变量的值的时候，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。



## mutable

mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。

```cpp
class ClxTest
{
　public:
　　void Output() const;
　　int GetOutputTimes() const;
 
　private:
　　mutable int m_iTimes;
};
 
 
void ClxTest::Output() const
{
　cout << "Output for test!" << endl;
　m_iTimes++;
}
 
```







## 数组和指针的区别？

数组可以在静态区、栈上创建，指针可以指向任意类型的内存地址。

sizeof可以计算数组的容量，不能识别指针指向地址的内存容量，数组作为参数时退化为指针。

## 程序跳转到指定内存地址

```c
*((void(*)())0x1000)() // 将程序跳转到绝对地址0x1000执行
    
(unsigned int*) 0x1000 = 1234; // 对绝对地址的赋值
(void(*)()) 0x1000 先将地址转化为指针函数，然后再调用它
```

## 字节序

计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的，所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序，所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

大端字节序：(网络字节序)，数据的低位放在地址的高位。

小端字节序：(本地字节序)，数据的低位存在地址的低位。

## 全局变量和局部变量

生命周期不同，操作系统和编译器通过内存分配的位置判断，全局变量分配到全局区，在程序运行前加载，既不变量分配到栈中。



## vector、map删除

vector的迭代器是连续的，删除元素之后，后面的元素会移动，所以不需要额外的++操作。

```cpp
void test10() {
    vector<int> arr{1, 1, 2, 3, 4, 1, 1, 5};
    auto it = arr.begin();

    while (it != arr.end()) {
        if (*it == 1) arr.erase(it);
        else it++;
    }
}
```



map删除迭代器之后，迭代器就失效了，所以要先得到下一个迭代器，先进行it++。

```cpp
void test9() {
    map<string, int> mp;
    mp["a"] = 1;
    mp["b"] = 1;
    mp["c"] = 2;
    mp["d"] = 1;
    mp["e"] = 3;

    auto it = mp.begin();
    while (it != mp.end()) {
        if (it->second == 1) {
            mp.erase(it++);
        }else {
            it++;
        }
    }
}
```



## 小知识点

- 类的大小

  空类的首地址有一个字节，表示类的内存地址。子类继承空类之后，如果子类有成员，空类的字节不会加到子类中。

- printf从右向左编译，从左向右输出，符合栈。

- 初始化列表执行的顺序是声明变量的顺序。

- 虚函数、成员函数、静态成员不占对象的内存空间，对象中有一个指向虚函数表的虚指针，64位占8字节。类的空间大小是成员中内存最大值的最小整数倍。

- 不能被继承的类

  将构造函数和析构函数设为私有，通过静态成员函数来调用构造函数。

- 只能在堆/栈上创建的对象

  只能在堆上创建：将构造、析构函数设为私有，使用静态成员函数调用构造函数，如果在栈上创建对象，编译器无法调用私有的构造函数。

  只能在栈上创建：将new、delete设为私有。

- sizeof计算结构体的大小时，每个成员的偏移量是成员大小的整数倍，结构体大小必须是所有成员大小的整数倍。

  ```c
  struct stru3   // 12
  {   
         char i;  //start address is 0 
         int m;   //start address is 4
         char n;  //start address is 8
  };  
  struct stru4  // 8
  {  
         char i;  //start address is 0
         char n;  //start address is 1
         int m;  //start address is 4
   };
  ```

- extern "C"

  告诉编译器代码使用C语言进行编译，C++出来之前，很多都是用C语言写的，为了支持原来的C代码。

- volatile修饰的变量随时获取最新值，默认如果代码中多次访问一块内存，编译器会将这个内存中的值放到寄存器中，这是编译器的一种优化，使用volatile可以避免这种优化。

- static关键字

  有默认值，只执行一次，放在全局区

  修饰类中成员函数，不依赖对象

- C++类型转换

  - 去const属性用const_cast。 
  - 基本类型转换用static_cast。 
  - 多态类之间的类型转换用daynamic_cast。 
  - 不同类型的指针类型转换用reinterpret_cast。

- 必须通过初始化列表的变量

  const常量、引用类型、没有默认构造函数(通过调用拷贝构造函数)
## 知识点

- 完全二叉树的叶子节点  $\lfloor\frac{n+1}{2}\rfloor$

- 二叉搜索树

  时间复杂度：$O(logn),O(n)$

  查找和添加元素通过比较大小来确定位置，删除元素需要借助前驱或者后继节点，交换之后删除。

  可能退化成链表。

- AVL树

  平衡二叉树，平衡的定义是左右子树的高度差不大于1。

  通过旋转操作来保持平衡。每调整最多$logn$次。

- 红黑树

  类似4阶B树，节点只有两种颜色，红色和黑色。红黑树不是绝对的平衡，牺牲平衡换取速度。

  节点是红色或黑色。

  根节点是黑色。

  叶子节点是黑色(NULL)

  红色节点的子节点是黑色

  - 红色节点的父节点是黑色
  - 根节点到叶子节点的所有路径上不能有2个连续的红色节点。

  任意节点到叶子节点的所有路径上包含相同数量的黑色节点。



  删除元素的时候，AVL可能要对所有的父节点的进行调整；红黑树最多三次旋转。

  AVL适于搜索多的操作，红黑树比较均衡。



## STL底层数据结构

- vector

  动态数组，在堆上分配空间，空间不够用的，以原大小的两倍新分配一个内存空间，最好将结构体或者类的指针放到vector中，防止移动的构造和析构。

  适合随机访问，不适合大量的插入和删除。

  n次push_back()的复杂度是$O(1)$，需要$logn$次扩容，每次拷贝$2^i$，均摊每次push_back的复杂度是$O(1)$

- list

  双向链表，不支持随机访问，插入删除元素，对应分配释放堆空间。

- deque

  双向开口的连续空间，可以在两端插入删除元素，支持随机访问。

- stack、queue

  先进后出、先进先出，适配器是对deque容器的再封装。

- priority_queue

  以vector为底层容器，加上heap处理规则

- set、multiset

  底层红黑树实现，按照键值排序，set没有重复元素，multiset可以有重复元素。

- map、unordered_map

  map底层红黑树，按照key排序，自定义类型数据需要重载 <

  unordered_map底层哈希表，自定义数据类型，需要重载 =



## Hash

Hash也称为散列、哈希。原理是把任意长度的输入，通过Hash计算得到一个固定长度的输出。

hash在数据结构中的含义和密码学中的含义并不相同，所以在这两种不同的领域里，算法的设计侧重点也不同。在密码学中，hash算法主要是用于消息摘要和签名。在数据结构中，hash主要是用于查询，侧重点在哈希算法的执行速度和冲突的解决。



### Hash的特点

- 不可逆性：不能从hash的值反向推到出原始数据。
- 均匀性：hash函数映射的值要保持均匀。
- 确定性：不同数据的hash值是不相同的。
- 混淆行：输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。
- 高效性：hash算法的执行效率要高效。



### Hash碰撞

Hash碰撞时不可避免的，解决碰撞的方法一般有两种：

- 开放地址法

  当发生冲突时，寻找一个空地址存放元素。

  - 线性探测法
  - 二次探测
  - 双重散列

  无论那种方法，当剩余空间很少时，冲突的发生的频率增加。需要设置一个装载因子来反映当前的冲突情况。$装载因子=\frac{输入的元素个数}{散列表的长度}$，如果超过了装载因子，可以对散列表进行扩充，重新进行hash。

- 链地址法

  使用链表保存数据，当存在冲突时，放到链表的后面。



### Hash的应用

- 信息加密，在服务端保存用户的密码的hash值，这样可以有效的避免密码的泄漏问题。但是如果所有的hash值被枚举出来了，也是不安全的。[CMD5 MD5密文查询](https://www.cmd5.com/)
- 数据校验，对数据生成hash值，判断是否被篡改。
- 版权校验，第一个用户上传的资源计算hash，后面如果出现相同的hash值就属于侵权，但是文件如果稍作改变就可能得到一个不同的hash值。（视频删除一帧，图像改变一个像素）。
- 大文件分块校验。大文件分开传输，为了保存文件时发布者自己传输的，可以对每个小文件做hash计算，如果小文件较多，可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash。
